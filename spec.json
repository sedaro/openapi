{
  "openapi": "3.0.2",
  "info": {
    "title": "Sedaro API",
    "description": "\nAllows for consumption of Sedaro services.\nRead more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).\n\n### Clients\n\n**Python:** [sedaro](https://pypi.org/project/sedaro/)\n- This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.\n\n### API Key\n\nTo access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the\nSedaro [Management Console](https://satellite.sedaro.com/account). Once complete, pass the API key in all requests\nvia the `X_API_KEY` HTTP header.\n\n*API keys grant full access to your account and should never be shared. If you think your API key has been compromised,\nyou can revoke it in the [Management Console](https://satellite.sedaro.com/account).*\n\n### Jupyter Notebooks\n\nFor additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).\n\n### Community, Support, Discussion\n\nIf you have any issues or suggestions, please reach out:\n\n1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow)\n2. Email us at support@sedarotech.com\n\n### Known Issues\n\n- Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned\nin all error cases.  Only a `200` status indicates success.  See a given error response for additional details.\n",
    "version": "4.11.36",
    "x-logo": {
      "url": "https://api.sedaro.com/static/multimedia/logo_secondary_06142023.png",
      "backgroundColor": "#FAFAFA",
      "altText": "Sedaro API Docs"
    }
  },
  "paths": {
    "/models/branches/{branchId}/template": {
      "patch": {
        "tags": ["Metamodels"],
        "summary": "Update a Metamodel",
        "description": "`Metamodel` `root` properties can be updated and multiple `Block`s can be created, updated, and/or deleted in the same\nrequest as follows:\n\n- Properties on the Metamodel root are updated via the `root` key.\n- `Block`s are **created** via dictionaries in the `Block`s list, making sure to include all required fields, the `type`\n(name of the class), and **exclude** an `id` property.\n- `Block`s are **updated** via dictionaries in the `Block`s list, making sure to **include** an `id` property, the `type`\n(name of the class) and any fields to be updated.\n- `Block`s are deleted via strings in the `delete` key corresponding to `id`s of `Block`s to be deleted.\n\n```json\n{\n    // UPDATE root properties\n    \"root\": {\n        \"property\": \"value\"\n    },\n    \"blocks\": [\n        // CREATE block\n        {\n            \"property\": \"value\",\n            \"type\": \"ClassName\",\n        },\n        // UPDATE block\n        {\n            \"id\": \"NWDjzoSSKT7yGJpZdSN9-\",\n            \"property\": \"value\",\n            \"type\": \"ClassName\",\n        },\n    ],\n    // DELETE blocks\n    \"delete\": [\"NWDk7l3UPDZ0AlJW2Ut0V\", \"NWDkZ7oToTp-W9IiutbnF\"]\n}\n```",
        "operationId": "crud_template",
        "parameters": [
          {
            "required": true,
            "schema": { "title": "Branchid", "type": "string" },
            "name": "branchId",
            "in": "path"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/MetamodelUpdateInterface"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": { "$ref": "#/components/schemas/ModelCrudRes" }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": { "$ref": "#/components/schemas/HTTPValidationError" }
              }
            }
          }
        },
        "security": [
          { "api_key_header_api_key": [] },
          { "api_key_header_auth_handle": [] }
        ]
      }
    },
    "/simulations/branches/{branchId}/control/": {
      "get": {
        "tags": ["Jobs"],
        "summary": "Get all simulations",
        "description": "`branchId` is the ID of the Scenario Branch for which to get all the Simulation Jobs. If the `latest` query param is included, only the most recent Simulation Job is included in the list.",
        "operationId": "get_simulations",
        "parameters": [
          {
            "required": true,
            "schema": { "title": "Branchid", "type": "string" },
            "name": "branchId",
            "in": "path"
          },
          {
            "required": false,
            "schema": { "title": "Latest", "enum": [""], "type": "string" },
            "name": "latest",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "title": "Response Get Simulations",
                  "anyOf": [
                    {
                      "type": "array",
                      "items": { "$ref": "#/components/schemas/SimulationJob" }
                    },
                    { "$ref": "#/components/schemas/SimulationJob" }
                  ]
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": { "$ref": "#/components/schemas/HTTPValidationError" }
              }
            }
          }
        },
        "security": [
          { "api_key_header_api_key": [] },
          { "api_key_header_auth_handle": [] }
        ]
      },
      "post": {
        "tags": ["Jobs"],
        "summary": "Start a simulation",
        "description": "Initiate a simulation for a given Scenario branch via the Sedaro Simulation Service.",
        "operationId": "start_simulation",
        "parameters": [
          {
            "description": "The ID of the Scenario Branch to start a simulation for.",
            "required": true,
            "schema": {
              "title": "Branch ID",
              "type": "string",
              "description": "The ID of the Scenario Branch to start a simulation for."
            },
            "example": "NWDjzoSSKT7yGJpZdSN9-",
            "name": "branchId",
            "in": "path"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "title": "Start Simulation Body",
                "allOf": [
                  { "$ref": "#/components/schemas/StartSimulationBody" }
                ],
                "description": "Arguments to the simulation start request"
              },
              "example": { "seed": 0 }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": { "$ref": "#/components/schemas/SimulationJob" }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": { "$ref": "#/components/schemas/HTTPValidationError" }
              }
            }
          }
        },
        "security": [
          { "api_key_header_api_key": [] },
          { "api_key_header_auth_handle": [] }
        ]
      }
    },
    "/simulations/branches/{branchId}/control/{jobId}": {
      "get": {
        "tags": ["Jobs"],
        "summary": "Get a simulation",
        "description": "`branchId` is the ID of the Scenario Branch simulated by the Simulation Job with ID `jobId`.",
        "operationId": "get_simulation",
        "parameters": [
          {
            "required": true,
            "schema": { "title": "Branchid", "type": "string" },
            "name": "branchId",
            "in": "path"
          },
          {
            "required": true,
            "schema": { "title": "Jobid", "type": "string" },
            "name": "jobId",
            "in": "path"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": { "$ref": "#/components/schemas/SimulationJob" }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": { "$ref": "#/components/schemas/HTTPValidationError" }
              }
            }
          }
        },
        "security": [
          { "api_key_header_api_key": [] },
          { "api_key_header_auth_handle": [] }
        ]
      },
      "delete": {
        "tags": ["Jobs"],
        "summary": "Terminate a simulation",
        "description": "`branchId` is the ID of the Scenario Branch simulated by the Simulation Job with ID `jobId`.",
        "operationId": "terminate_simulation",
        "parameters": [
          {
            "required": true,
            "schema": { "title": "Branchid", "type": "string" },
            "name": "branchId",
            "in": "path"
          },
          {
            "required": true,
            "schema": { "title": "Jobid", "type": "string" },
            "name": "jobId",
            "in": "path"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": { "$ref": "#/components/schemas/MessageRes" }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": { "$ref": "#/components/schemas/HTTPValidationError" }
              }
            }
          }
        },
        "security": [
          { "api_key_header_api_key": [] },
          { "api_key_header_auth_handle": [] }
        ]
      }
    },
    "/simulations/branches/{branchId}/control/study/": {
      "get": {
        "tags": ["Jobs"],
        "summary": "Get all studies",
        "description": "`branchId` is the ID of the Scenario Template Branch for which to get all the Study Jobs. If the `latest` query param is included, only the most recent Study Job is included in the list.",
        "operationId": "get_studies",
        "parameters": [
          {
            "required": true,
            "schema": { "title": "Branchid", "type": "string" },
            "name": "branchId",
            "in": "path"
          },
          {
            "required": false,
            "schema": { "title": "Latest", "enum": [""], "type": "string" },
            "name": "latest",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "title": "Response Get Studies",
                  "anyOf": [
                    {
                      "type": "array",
                      "items": { "$ref": "#/components/schemas/StudyJob" }
                    },
                    { "$ref": "#/components/schemas/StudyJob" }
                  ]
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": { "$ref": "#/components/schemas/HTTPValidationError" }
              }
            }
          }
        },
        "security": [
          { "api_key_header_api_key": [] },
          { "api_key_header_auth_handle": [] }
        ]
      },
      "post": {
        "tags": ["Jobs"],
        "summary": "Start a study",
        "description": "`branchId` is the ID of the Scenario Template Branch to simulate.",
        "operationId": "start_study",
        "parameters": [
          {
            "required": true,
            "schema": { "title": "Branchid", "type": "string" },
            "name": "branchId",
            "in": "path"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": { "$ref": "#/components/schemas/StartStudyBody" }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": { "$ref": "#/components/schemas/StudyJob" }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": { "$ref": "#/components/schemas/HTTPValidationError" }
              }
            }
          }
        },
        "security": [
          { "api_key_header_api_key": [] },
          { "api_key_header_auth_handle": [] }
        ]
      }
    },
    "/simulations/branches/{branchId}/control/study/{jobId}": {
      "get": {
        "tags": ["Jobs"],
        "summary": "Get a study",
        "description": "`branchId` is the ID of the Scenario Template Branch simulated by the Simulation Job with ID `jobId`.",
        "operationId": "get_study",
        "parameters": [
          {
            "required": true,
            "schema": { "title": "Branchid", "type": "string" },
            "name": "branchId",
            "in": "path"
          },
          {
            "required": true,
            "schema": { "title": "Jobid", "type": "string" },
            "name": "jobId",
            "in": "path"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": { "$ref": "#/components/schemas/StudyJob" }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": { "$ref": "#/components/schemas/HTTPValidationError" }
              }
            }
          }
        },
        "security": [
          { "api_key_header_api_key": [] },
          { "api_key_header_auth_handle": [] }
        ]
      },
      "delete": {
        "tags": ["Jobs"],
        "summary": "Terminate a study",
        "description": "`branchId` is the ID of the Scenario Template Branch simulated by the Simulation Job with ID `jobId`.",
        "operationId": "terminate_study",
        "parameters": [
          {
            "required": true,
            "schema": { "title": "Branchid", "type": "string" },
            "name": "branchId",
            "in": "path"
          },
          {
            "required": true,
            "schema": { "title": "Jobid", "type": "string" },
            "name": "jobId",
            "in": "path"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": { "$ref": "#/components/schemas/MessageRes" }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": { "$ref": "#/components/schemas/HTTPValidationError" }
              }
            }
          }
        },
        "security": [
          { "api_key_header_api_key": [] },
          { "api_key_header_auth_handle": [] }
        ]
      }
    },
    "/simulations/jobs/{jobId}/externals/{agentId}/{externalStateBlockId}": {
      "get": {
        "tags": ["Externals"],
        "summary": "Read `ExternalState` for a simulation",
        "description": "This endpoint is used to read/consume state from a running simulation.\n- `jobId`: The ID of the running simulation for which to communicate\n- `agentId`: The ID of the `Agent` in the simulation for which the produced state pertains\n- `externalStateBlockId`: The ID of the relevant `ExternalState` Block of the `Agent` with ID `agentId` which defines the `consumed` state variables.\n- `time` (optional): The simulation `time` at which to read the `consumed` state. During `SpontaneousExternalState`\ntransactions, if `time` is omitted, the relevant Engine's `time` will be used.  `time` should be omitted for `PerRoundExternalState` transactions.",
        "operationId": "get_external",
        "parameters": [
          {
            "required": true,
            "schema": { "title": "Jobid", "type": "string" },
            "name": "jobId",
            "in": "path"
          },
          {
            "required": true,
            "schema": { "title": "Agentid", "type": "string" },
            "name": "agentId",
            "in": "path"
          },
          {
            "required": true,
            "schema": { "title": "Externalstateblockid", "type": "string" },
            "name": "externalStateBlockId",
            "in": "path"
          },
          {
            "required": false,
            "schema": { "title": "Time", "type": "number" },
            "name": "time",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "title": "Response Get External",
                  "type": "array",
                  "items": {}
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": { "$ref": "#/components/schemas/HTTPValidationError" }
              }
            }
          }
        },
        "security": [
          { "api_key_header_api_key": [] },
          { "api_key_header_auth_handle": [] }
        ]
      },
      "patch": {
        "tags": ["Externals"],
        "summary": "Set `ExternalState` for a simulation",
        "description": "This endpoint is used to publish/produce state to a running simulation.\n- `jobId`: The ID of the running simulation for which to communicate\n- `agentId`: The ID of the `Agent` in the simulation for which the produced state pertains\n- `externalStateBlockId`: The ID of the relevant `ExternalState` Block of the `Agent` with ID `agentId` which defines the `produced` state variables.\n\nSee details on the request body below.",
        "operationId": "put_external",
        "parameters": [
          {
            "required": true,
            "schema": { "title": "Jobid", "type": "string" },
            "name": "jobId",
            "in": "path"
          },
          {
            "required": true,
            "schema": { "title": "Agentid", "type": "string" },
            "name": "agentId",
            "in": "path"
          },
          {
            "required": true,
            "schema": { "title": "Externalstateblockid", "type": "string" },
            "name": "externalStateBlockId",
            "in": "path"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ExternalStateSetRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "title": "Response Put External",
                  "type": "array",
                  "items": {}
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": { "$ref": "#/components/schemas/HTTPValidationError" }
              }
            }
          }
        },
        "security": [
          { "api_key_header_api_key": [] },
          { "api_key_header_auth_handle": [] }
        ]
      }
    },
    "/data/{id}": {
      "get": {
        "tags": ["Data"],
        "summary": "Query Data",
        "description": "Queries Data Service data set with ID `id`.",
        "operationId": "get_data",
        "parameters": [
          {
            "required": true,
            "schema": { "title": "Id", "type": "string" },
            "name": "id",
            "in": "path"
          },
          {
            "required": false,
            "schema": { "title": "Start", "type": "number" },
            "name": "start",
            "in": "query"
          },
          {
            "required": false,
            "schema": { "title": "Stop", "type": "number" },
            "name": "stop",
            "in": "query"
          },
          {
            "required": false,
            "schema": { "title": "Streams", "type": "string" },
            "name": "streams",
            "in": "query"
          },
          {
            "required": false,
            "schema": { "title": "Streamstoken", "type": "string" },
            "name": "streamsToken",
            "in": "query"
          },
          {
            "required": false,
            "schema": { "title": "Shape", "type": "string" },
            "name": "shape",
            "in": "query"
          },
          {
            "required": false,
            "schema": { "title": "Axisorder", "type": "string" },
            "name": "axisOrder",
            "in": "query"
          },
          {
            "required": false,
            "schema": { "title": "Binwidth", "type": "integer" },
            "name": "binWidth",
            "in": "query"
          },
          {
            "required": false,
            "schema": { "title": "Samplerate", "type": "integer" },
            "name": "sampleRate",
            "in": "query"
          },
          {
            "required": false,
            "schema": { "title": "Continuationtoken", "type": "string" },
            "name": "continuationToken",
            "in": "query"
          },
          {
            "required": false,
            "schema": { "title": "Encoding", "type": "string" },
            "name": "encoding",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": { "$ref": "#/components/schemas/DataServiceResponse" }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": { "$ref": "#/components/schemas/HTTPValidationError" }
              }
            }
          }
        },
        "security": [
          { "api_key_header_api_key": [] },
          { "api_key_header_auth_handle": [] }
        ]
      }
    },
    "/models/repositories/": {
      "post": {
        "tags": ["Repositories"],
        "summary": "Create new repository",
        "description": "Creates a new repository based on the body params. The new repository will begin with a default branch.",
        "operationId": "create_repo",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": { "$ref": "#/components/schemas/RepoCreateReq" }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": { "$ref": "#/components/schemas/RepoRes" }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": { "$ref": "#/components/schemas/HTTPValidationError" }
              }
            }
          }
        },
        "security": [
          { "api_key_header_api_key": [] },
          { "api_key_header_auth_handle": [] }
        ]
      }
    },
    "/models/repositories/{repositoryId}": {
      "get": {
        "tags": ["Repositories"],
        "summary": "Get repository",
        "description": "Gets a repository with `id` of given `repoId`.",
        "operationId": "get_repo",
        "parameters": [
          {
            "required": true,
            "schema": { "title": "Repositoryid", "type": "string" },
            "name": "repositoryId",
            "in": "path"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": { "$ref": "#/components/schemas/RepoRes" }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": { "$ref": "#/components/schemas/HTTPValidationError" }
              }
            }
          }
        },
        "security": [
          { "api_key_header_api_key": [] },
          { "api_key_header_auth_handle": [] }
        ]
      },
      "delete": {
        "tags": ["Repositories"],
        "summary": "Delete repository",
        "description": "Deletes a repository with `id` of given `repoId` and all associated branches.",
        "operationId": "delete_repo",
        "parameters": [
          {
            "required": true,
            "schema": { "title": "Repositoryid", "type": "string" },
            "name": "repositoryId",
            "in": "path"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": { "$ref": "#/components/schemas/EntityDeleteRes" }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": { "$ref": "#/components/schemas/HTTPValidationError" }
              }
            }
          }
        },
        "security": [
          { "api_key_header_api_key": [] },
          { "api_key_header_auth_handle": [] }
        ]
      },
      "patch": {
        "tags": ["Repositories"],
        "summary": "Update repository",
        "description": "Updates a repository with `id` of given `repoId` based on the body params.",
        "operationId": "update_repo",
        "parameters": [
          {
            "required": true,
            "schema": { "title": "Repositoryid", "type": "string" },
            "name": "repositoryId",
            "in": "path"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": { "$ref": "#/components/schemas/RepoUpdateReq" }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": { "$ref": "#/components/schemas/RepoRes" }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": { "$ref": "#/components/schemas/HTTPValidationError" }
              }
            }
          }
        },
        "security": [
          { "api_key_header_api_key": [] },
          { "api_key_header_auth_handle": [] }
        ]
      }
    },
    "/models/repositories/import": {
      "post": {
        "tags": ["Repositories"],
        "summary": "Import branch as new repository",
        "description": "Imports the branch(es) from the uploaded zip file into the workspace associated with workspace `id` from the\n        body. All branches will be in their own repo and given new `id`s. For info on exporting, see the branches [export\n        route](#operation/export_branch).",
        "operationId": "import_branch_as_new_repo",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": { "$ref": "#/components/schemas/RepoImportReq" }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": { "$ref": "#/components/schemas/MessageRes" }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": { "$ref": "#/components/schemas/HTTPValidationError" }
              }
            }
          }
        },
        "security": [
          { "api_key_header_api_key": [] },
          { "api_key_header_auth_handle": [] }
        ]
      }
    },
    "/models/branches/{branchId}": {
      "get": {
        "tags": ["Branches"],
        "summary": "Get a branch",
        "description": "Retrieves the branch with the provided `id`.",
        "operationId": "get_branch",
        "parameters": [
          {
            "required": true,
            "schema": { "title": "Branchid", "type": "string" },
            "name": "branchId",
            "in": "path"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": { "$ref": "#/components/schemas/BranchRes" }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": { "$ref": "#/components/schemas/HTTPValidationError" }
              }
            }
          }
        },
        "security": [
          { "api_key_header_api_key": [] },
          { "api_key_header_auth_handle": [] }
        ]
      },
      "post": {
        "tags": ["Branches"],
        "summary": "Branch off existing branch",
        "description": "Creates a new branch based on and in the same repository as the branch associated with the provided `id`.",
        "operationId": "create_branch",
        "parameters": [
          {
            "required": true,
            "schema": { "title": "Branchid", "type": "string" },
            "name": "branchId",
            "in": "path"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": { "$ref": "#/components/schemas/BranchCreate" }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": { "$ref": "#/components/schemas/BranchRes" }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": { "$ref": "#/components/schemas/HTTPValidationError" }
              }
            }
          }
        },
        "security": [
          { "api_key_header_api_key": [] },
          { "api_key_header_auth_handle": [] }
        ]
      },
      "delete": {
        "tags": ["Branches"],
        "summary": "Delete a branch",
        "description": "Deletes the branch with the provided `id`.",
        "operationId": "delete_branch",
        "parameters": [
          {
            "required": true,
            "schema": { "title": "Branchid", "type": "string" },
            "name": "branchId",
            "in": "path"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": { "$ref": "#/components/schemas/EntityDeleteRes" }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": { "$ref": "#/components/schemas/HTTPValidationError" }
              }
            }
          }
        },
        "security": [
          { "api_key_header_api_key": [] },
          { "api_key_header_auth_handle": [] }
        ]
      },
      "patch": {
        "tags": ["Branches"],
        "summary": "Update a branch",
        "description": "Updates updateable fields on the branch with the provided `id`. Note:\n- `shareable` indicates whether shareable links are valid for this branch.\n- `password` indicates whether the shareable link requires a password.",
        "operationId": "update_branch",
        "parameters": [
          {
            "required": true,
            "schema": { "title": "Branchid", "type": "string" },
            "name": "branchId",
            "in": "path"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": { "$ref": "#/components/schemas/BranchUpdate" }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": { "$ref": "#/components/schemas/BranchRes" }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": { "$ref": "#/components/schemas/HTTPValidationError" }
              }
            }
          }
        },
        "security": [
          { "api_key_header_api_key": [] },
          { "api_key_header_auth_handle": [] }
        ]
      }
    },
    "/models/branches/{branchId}/share-auth/": {
      "post": {
        "tags": ["Branches"],
        "summary": "Verify branch password",
        "description": "Route to verify password when a user tries to access a branch with the provided `id` via a password protected shareable link.\nIf successful, returns a success message with a set-cookie. The cookie stores a `jwt` that allows for non-owner collaborators to send `GET` requests to the corresponding branch.",
        "operationId": "verify_branch_password",
        "parameters": [
          {
            "required": true,
            "schema": { "title": "Branchid", "type": "string" },
            "name": "branchId",
            "in": "path"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": { "$ref": "#/components/schemas/BranchVerifyPassword" }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": { "$ref": "#/components/schemas/MessageRes" }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": { "$ref": "#/components/schemas/HTTPValidationError" }
              }
            }
          }
        },
        "security": [
          { "api_key_header_api_key": [] },
          { "api_key_header_auth_handle": [] }
        ]
      }
    },
    "/models/branches/{branchId}/commits/": {
      "post": {
        "tags": ["Branches"],
        "summary": "Commit changes to a branch",
        "description": "Takes all changes to the blocks on the branch with the provided `id` and commits them to the corresponding version-controlled branch.",
        "operationId": "commit_to_branch",
        "parameters": [
          {
            "required": true,
            "schema": { "title": "Branchid", "type": "string" },
            "name": "branchId",
            "in": "path"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": { "$ref": "#/components/schemas/CommitMessage" }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": { "$ref": "#/components/schemas/MessageRes" }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": { "$ref": "#/components/schemas/HTTPValidationError" }
              }
            }
          }
        },
        "security": [
          { "api_key_header_api_key": [] },
          { "api_key_header_auth_handle": [] }
        ]
      }
    },
    "/models/branches/{currentBranchId}/merge/{incomingBranchId}": {
      "post": {
        "tags": ["Branches"],
        "summary": "Merge branch into another branch",
        "description": "Merges branch with `incomingBranchId` into branch with `currentBranchId`. This route has two functions:\n- To initiate the merge, send the request with no body. If there are no conflicts, it will successfully complete the merge and send back the resulting branch.\n- If there are conflicts, the response body will have a key of `conflicts` with a list of conflict objects outlining the \"current\" and \"incoming\" changes. Review the list, and send a second request to the same route including a list of resulutions (see optional `resultions` param in the request body schema below) indicating where you would like to keep the \"current\" or \"incoming\" changes. The indices in the `resultions` list should correspond with the indices of the `conflicts` list.",
        "operationId": "merge_branches",
        "parameters": [
          {
            "required": true,
            "schema": { "title": "Currentbranchid", "type": "string" },
            "name": "currentBranchId",
            "in": "path"
          },
          {
            "required": true,
            "schema": { "title": "Incomingbranchid", "type": "string" },
            "name": "incomingBranchId",
            "in": "path"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": { "$ref": "#/components/schemas/BranchMerge" }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "title": "Response Merge Branches",
                  "anyOf": [
                    { "$ref": "#/components/schemas/BranchRes" },
                    { "$ref": "#/components/schemas/BranchMergeConflictsRes" }
                  ]
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": { "$ref": "#/components/schemas/HTTPValidationError" }
              }
            }
          }
        },
        "security": [
          { "api_key_header_api_key": [] },
          { "api_key_header_auth_handle": [] }
        ]
      }
    },
    "/models/branches/{branchId}/committed/": {
      "get": {
        "tags": ["Branches"],
        "summary": "Get saved branch data",
        "description": "Retrieves all **committed** branch `data` (`Metamodel` without the meta attributes) from the branch with the given `id`.",
        "operationId": "get_committed_branch_data",
        "parameters": [
          {
            "required": true,
            "schema": { "title": "Branchid", "type": "string" },
            "name": "branchId",
            "in": "path"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "title": "Response Get Committed Branch Data",
                  "anyOf": [
                    { "$ref": "#/components/schemas/Scenario" },
                    { "$ref": "#/components/schemas/Spacecraft" },
                    { "$ref": "#/components/schemas/TerrestrialVehicle" }
                  ]
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": { "$ref": "#/components/schemas/HTTPValidationError" }
              }
            }
          }
        },
        "security": [
          { "api_key_header_api_key": [] },
          { "api_key_header_auth_handle": [] }
        ]
      }
    },
    "/models/branches/{branchId}/saved/": {
      "get": {
        "tags": ["Branches"],
        "summary": "Get committed branch data",
        "description": "Retrieves all **saved** branch `data` (`Metamodel` without the meta attributes) from the branch with the given `id`.",
        "operationId": "get_saved_branch_data",
        "parameters": [
          {
            "required": true,
            "schema": { "title": "Branchid", "type": "string" },
            "name": "branchId",
            "in": "path"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "title": "Response Get Saved Branch Data",
                  "anyOf": [
                    { "$ref": "#/components/schemas/Scenario" },
                    { "$ref": "#/components/schemas/Spacecraft" },
                    { "$ref": "#/components/schemas/TerrestrialVehicle" }
                  ]
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": { "$ref": "#/components/schemas/HTTPValidationError" }
              }
            }
          }
        },
        "security": [
          { "api_key_header_api_key": [] },
          { "api_key_header_auth_handle": [] }
        ]
      }
    },
    "/models/branches/{branchId}/changes/": {
      "get": {
        "tags": ["Branches"],
        "summary": "Get branch changes",
        "description": "Retrieves the state of the saved branch `data` and committed branch `data` with the given `id` and returns them for comparison.",
        "operationId": "get_branch_changes",
        "parameters": [
          {
            "required": true,
            "schema": { "title": "Branchid", "type": "string" },
            "name": "branchId",
            "in": "path"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": { "$ref": "#/components/schemas/BranchChangesRes" }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": { "$ref": "#/components/schemas/HTTPValidationError" }
              }
            }
          }
        },
        "security": [
          { "api_key_header_api_key": [] },
          { "api_key_header_auth_handle": [] }
        ]
      }
    },
    "/models/branches/{branchId}/export/": {
      "get": {
        "tags": ["Branches"],
        "summary": "Export branch",
        "description": "Exports the branch with `id` of given `branchId`. If the branch is a Scenario, also exports all branches\n        referenced in the Scenario's agents. The returned `FileResponse` contains exported branch(es) as a json file(s)\n        zipped in a directory. For info on importing, see the repositories [import route](#operation/import_branch_as_new_repo).",
        "operationId": "export_branch",
        "parameters": [
          {
            "required": true,
            "schema": { "title": "Branchid", "type": "string" },
            "name": "branchId",
            "in": "path"
          }
        ],
        "responses": {
          "200": { "description": "Successful Response" },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": { "$ref": "#/components/schemas/HTTPValidationError" }
              }
            }
          }
        },
        "security": [
          { "api_key_header_api_key": [] },
          { "api_key_header_auth_handle": [] }
        ]
      }
    }
  },
  "components": {
    "schemas": {
      "BranchChangesRes": {
        "title": "BranchChangesRes",
        "required": ["edited", "committed"],
        "type": "object",
        "properties": {
          "edited": {
            "title": "Edited",
            "anyOf": [
              { "$ref": "#/components/schemas/Scenario" },
              { "$ref": "#/components/schemas/Spacecraft" },
              { "$ref": "#/components/schemas/TerrestrialVehicle" }
            ],
            "description": "The edited/ saved changes."
          },
          "committed": {
            "title": "Committed",
            "anyOf": [
              { "$ref": "#/components/schemas/Scenario" },
              { "$ref": "#/components/schemas/Spacecraft" },
              { "$ref": "#/components/schemas/TerrestrialVehicle" }
            ],
            "description": "The committed changes."
          }
        }
      },
      "BranchCreate": {
        "title": "BranchCreate",
        "required": ["name"],
        "type": "object",
        "properties": {
          "name": {
            "title": "Name",
            "maxLength": 32,
            "type": "string",
            "description": "The name of the branch to create."
          },
          "description": {
            "title": "Description",
            "maxLength": 300,
            "type": "string",
            "description": "The description of the the branch to create."
          }
        }
      },
      "BranchMerge": {
        "title": "BranchMerge",
        "type": "object",
        "properties": {
          "resolutions": {
            "title": "Resolutions",
            "type": "array",
            "items": { "enum": ["current", "incoming"], "type": "string" },
            "description": "The two branches to be merged."
          }
        }
      },
      "BranchMergeConflictsRes": {
        "title": "BranchMergeConflictsRes",
        "required": ["conflicts"],
        "type": "object",
        "properties": {
          "conflicts": {
            "title": "Conflicts",
            "type": "array",
            "items": { "$ref": "#/components/schemas/ConflictsObj" },
            "description": "The list of conflict."
          }
        }
      },
      "BranchRes": {
        "title": "BranchRes",
        "required": ["id", "dateCreated", "dateModified", "name", "data"],
        "type": "object",
        "properties": {
          "id": {
            "title": "ID",
            "type": "string",
            "description": "The id of the branch."
          },
          "dateCreated": {
            "title": "DateCreated",
            "type": "string",
            "description": "The date the branch was created.",
            "format": "date-time"
          },
          "dateModified": {
            "title": "DateModified",
            "type": "string",
            "description": "The date the branch was last modified.",
            "format": "date-time"
          },
          "repository": {
            "title": "Repository",
            "description": "The repository of the branch."
          },
          "createdBy": {
            "title": "Created By",
            "description": "The Id of the user that created the branch."
          },
          "description": {
            "title": "Description",
            "type": "string",
            "description": "The description of the branch."
          },
          "key": {
            "title": "Key",
            "type": "string",
            "description": "The key of the branch."
          },
          "lastModifiedBy": {
            "title": "Last Modified By",
            "type": "string",
            "description": "The Id of the user that last modified the branch.."
          },
          "metamodelType": {
            "title": "Metamodel Type",
            "type": "string",
            "description": "The model type of the branch."
          },
          "mission": {
            "title": "Mission",
            "type": "string",
            "description": "The mission of the branch."
          },
          "name": {
            "title": "Name",
            "type": "string",
            "description": "The name of the branch."
          },
          "numSimulations": {
            "title": "Num Simulations",
            "type": "integer",
            "description": "The number of simulations in the branch."
          },
          "repoType": {
            "title": "Repo Type",
            "type": "string",
            "description": "The repository type of the branch."
          },
          "schema": {
            "title": "Schema",
            "type": "object",
            "description": "The schema of the branch."
          },
          "sharePasswordRequired": {
            "title": "Share Password Required",
            "type": "boolean",
            "description": "A boolean specifying if a share password is required for the branch."
          },
          "shareable": {
            "title": "Shareable",
            "type": "boolean",
            "description": "A boolean specifying if the branch is sharable."
          },
          "targetGroups": {
            "title": "Target Groups",
            "type": "array",
            "items": { "type": "string" },
            "description": "The target groups in the branch."
          },
          "targets": {
            "title": "Targets",
            "type": "array",
            "items": { "type": "string" },
            "description": "The branch targets."
          },
          "workspace": {
            "title": "Workspace",
            "description": "The workspace where the branch exist."
          },
          "cadScaleFactor": {
            "title": "Cad Scale Factor",
            "description": "The cad scale facto."
          },
          "cadSignedUrl": {
            "title": "Cad Signed Url",
            "description": "The cad signed Url."
          },
          "data": {
            "title": "Data",
            "anyOf": [
              { "$ref": "#/components/schemas/Scenario" },
              { "$ref": "#/components/schemas/Spacecraft" },
              { "$ref": "#/components/schemas/TerrestrialVehicle" }
            ],
            "description": "The branch response depending on each model the branch belongs to."
          }
        }
      },
      "BranchUpdate": {
        "title": "BranchUpdate",
        "type": "object",
        "properties": {
          "name": {
            "title": "Name",
            "maxLength": 32,
            "type": "string",
            "description": "The name of the branch to update"
          },
          "description": {
            "title": "Description",
            "maxLength": 300,
            "type": "string",
            "description": "The description of the the branch to create."
          },
          "shareable": {
            "title": "Shareable",
            "type": "boolean",
            "description": "A boolean specifying if the branch is sharable."
          },
          "password": {
            "title": "Password",
            "type": "string",
            "description": "The password of the branch if it is protected/ not sharable."
          }
        }
      },
      "BranchVerifyPassword": {
        "title": "BranchVerifyPassword",
        "required": ["password"],
        "type": "object",
        "properties": {
          "password": {
            "title": "Password",
            "type": "string",
            "description": "The password of the branch if it is protected/ not sharable."
          }
        }
      },
      "CommitMessage": {
        "title": "CommitMessage",
        "required": ["commitMessage"],
        "type": "object",
        "properties": {
          "commitMessage": {
            "title": "Commit Message",
            "type": "string",
            "description": "The commit message."
          }
        }
      },
      "ConflictsObj": {
        "title": "ConflictsObj",
        "required": ["current", "incoming", "block"],
        "type": "object",
        "properties": {
          "current": {
            "title": "Current",
            "type": "object",
            "description": "The current branch to be merged."
          },
          "incoming": {
            "title": "Incoming",
            "type": "object",
            "description": "The incoming branch to be merged."
          },
          "block": {
            "title": "Block",
            "type": "string",
            "description": "The block that contains the conflict."
          }
        }
      },
      "CrudRes": {
        "title": "CrudRes",
        "required": ["blocks", "delete", "root"],
        "type": "object",
        "properties": {
          "blocks": {
            "title": "Blocks",
            "type": "array",
            "items": { "type": "string" },
            "description": "The blocks attribute in the meta model interface."
          },
          "delete": {
            "title": "Delete",
            "type": "array",
            "items": { "type": "string" },
            "description": "A variable used to delete a list of blocks in the meta model interface."
          },
          "root": {
            "title": "Root",
            "type": "array",
            "items": {},
            "description": "The root attribute in the meta model interface."
          }
        }
      },
      "DataServiceResponse": {
        "title": "DataServiceResponse",
        "required": ["meta", "series"],
        "type": "object",
        "properties": {
          "meta": { "title": "Meta", "type": "object" },
          "series": { "title": "Series", "type": "object" }
        }
      },
      "DeletedEntity": {
        "title": "DeletedEntity",
        "required": ["model", "id"],
        "type": "object",
        "properties": {
          "model": {
            "title": "Model",
            "type": "string",
            "description": "The model type of deleted entity."
          },
          "id": {
            "title": "ID",
            "type": "string",
            "description": "The id of deleted entity."
          }
        }
      },
      "EntityDeleteRes": {
        "title": "EntityDeleteRes",
        "required": ["message", "deletedEntities"],
        "type": "object",
        "properties": {
          "message": {
            "title": "Message",
            "type": "string",
            "description": "The message of deleted entity."
          },
          "deletedEntities": {
            "title": "Deleted Entities",
            "type": "array",
            "items": { "$ref": "#/components/schemas/DeletedEntity" },
            "description": "A list of deleted entities."
          }
        }
      },
      "ExternalStateSetRequest": {
        "title": "ExternalStateSetRequest",
        "type": "object",
        "properties": {
          "values": {
            "title": "External State Values",
            "type": "array",
            "items": { "type": "number" },
            "description": "\nA list containing the values of the external state to be produced.  The shape of this list and its\ncontents should match that defined by the `produced` query on the `ExternalState` block targeted by this request.\n\nExamples:\n```python\nblock = {\n  produced: [\n    {'root': 'velocity'},\n  ],\n  ...\n}\nvalues == [\n    [1, 0, 0]\n]\n\nblock = {\n  produced: [\n    {'root': 'velocity'},\n    {'root': 'commandedAttitude'},\n  ],\n  ...\n}\nvalues == [\n    [1, 0, 0],\n    [0, 0, 0, 1]\n]\n\nblock = {\n  produced: [\n    {'root': 'velocity'},\n    {'Battery': 'voltage'},\n    # Recall that this syntax queries for the `voltage` of all blocks of type `Battery` in the model.\n    # In this example, assume there is a single Battery\n  ],\n  ...\n}\nvalues == [\n    [1, 0, 0],\n    [28.2]\n]\n```\n\nSome state must be produced as numpy arrays.  In this case, follow the numpy serialization/deserialization approach described above.\n",
            "default": []
          },
          "timestamp": {
            "title": "External State Values Timestamp [MJD]",
            "type": "number",
            "description": "\nThe timestamp of the external state `values`. `values` take effect once the relevant simulation\nEngine's `time` is >= `timestamp`. When a `timestamp` is provided, all future `timestamp`s must be\nsequential and increasing. When multiple `timestamp`ed `values` exist in a queue, the most current for\nwhich `time` is >= `timestamp` is taken.\n\nDuring `SpontaneousExternalState` transactions, if `timestamp` is omitted, the relevant Engine's `time` will be used.\n`timestamp` should be omitted for `PerRoundExternalState` transactions.\n"
          }
        }
      },
      "HTTPValidationError": {
        "title": "HTTPValidationError",
        "type": "object",
        "properties": {
          "detail": {
            "title": "Detail",
            "type": "array",
            "items": { "$ref": "#/components/schemas/ValidationError" }
          }
        }
      },
      "Issues": {
        "title": "Issues",
        "type": "object",
        "properties": {
          "errors": {
            "title": "Errors",
            "type": "object",
            "additionalProperties": {
              "type": "array",
              "items": { "type": "string" }
            }
          },
          "warnings": {
            "title": "Warnings",
            "type": "object",
            "additionalProperties": {
              "type": "array",
              "items": { "type": "string" }
            }
          }
        },
        "additionalProperties": false,
        "description": "Inherit from this class to type fields on a `Metamodel`, `Block` or `FieldSchema`"
      },
      "MessageRes": {
        "title": "MessageRes",
        "required": ["message"],
        "type": "object",
        "properties": {
          "message": {
            "title": "Message",
            "type": "string",
            "description": "The message of deleted entity."
          }
        }
      },
      "MetamodelUpdateInterface": {
        "title": "MetamodelUpdateInterface",
        "type": "object",
        "properties": {
          "root": {
            "title": "Root",
            "type": "object",
            "description": "The root attribute in the meta model interface."
          },
          "blocks": {
            "title": "Blocks",
            "type": "array",
            "items": { "type": "object" },
            "description": "The blocks attribute in the meta model interface."
          },
          "delete": {
            "title": "delete",
            "type": "array",
            "items": { "type": "string" },
            "description": "A variable used to delete a list of blocks in the meta model interface."
          }
        }
      },
      "ModelCrudRes": {
        "title": "ModelCrudRes",
        "required": ["crud", "branch"],
        "type": "object",
        "properties": {
          "crud": {
            "title": "CrudRes",
            "allOf": [{ "$ref": "#/components/schemas/CrudRes" }],
            "description": "The crud class to make changes to the meta model interface."
          },
          "branch": {
            "title": "BranchRes",
            "allOf": [{ "$ref": "#/components/schemas/BranchRes" }],
            "description": "The branch response after the changes."
          }
        }
      },
      "Progress": {
        "title": "Progress",
        "type": "object",
        "properties": {
          "percentComplete": {
            "title": "Completion Percentage [%]",
            "type": "number",
            "description": "The completion percentage."
          },
          "currentTime": {
            "title": "Current Simulation Time [MJD]",
            "type": "number",
            "description": "The current simulation time."
          },
          "argMinTimeStep": {
            "title": "Simulation Min Time step arguments",
            "type": "array",
            "items": {},
            "description": "The simulation min time step arguments."
          },
          "minTimeStep": {
            "title": "Simulation Min Time step [MJD]",
            "type": "number",
            "description": "The simulation min time step."
          },
          "startTime": {
            "title": "Start Simulation Time [MJD]",
            "type": "number",
            "description": "The start simulation time."
          },
          "stopTime": {
            "title": "Stop Simulation Time [MJD]",
            "type": "number",
            "description": "The stop simulation time."
          }
        }
      },
      "RepoCreateReq": {
        "title": "RepoCreateReq",
        "required": ["name", "workspace", "metamodelType"],
        "type": "object",
        "properties": {
          "name": {
            "title": "Name",
            "maxLength": 64,
            "type": "string",
            "description": "The name of the repo."
          },
          "description": {
            "title": "Description",
            "maxLength": 1000,
            "type": "string",
            "description": "The description of the repo."
          },
          "workspace": {
            "title": "Workspace",
            "type": "string",
            "description": "The workspace where the repo exist."
          },
          "metamodelType": {
            "title": "Metamodel Type",
            "type": "string",
            "description": "The Metamodel type of the repo."
          }
        }
      },
      "RepoImportReq": {
        "title": "RepoImportReq",
        "required": ["workspace", "file"],
        "type": "object",
        "properties": {
          "workspace": {
            "title": "Workspace",
            "type": "string",
            "description": "The workspace where the repo exist."
          },
          "file": {
            "title": "UploadFile",
            "type": "string",
            "description": "The uploadFile that contains the repo in the form of a zip file.",
            "format": "binary"
          }
        }
      },
      "RepoRes": {
        "title": "RepoRes",
        "required": [
          "id",
          "name",
          "workspace",
          "metamodelType",
          "dateCreated",
          "dateModified",
          "branches",
          "createdBy",
          "lastModifiedBy",
          "repoType",
          "versions"
        ],
        "type": "object",
        "properties": {
          "id": {
            "title": "ID",
            "type": "string",
            "description": "The Id of the repo."
          },
          "name": {
            "title": "Name",
            "maxLength": 64,
            "type": "string",
            "description": "The name of the repo."
          },
          "description": {
            "title": "Description",
            "maxLength": 1000,
            "type": "string",
            "description": "The description of the repo."
          },
          "workspace": {
            "title": "Workspace",
            "type": "object",
            "description": "The workspace where the repo exist."
          },
          "metamodelType": {
            "title": "Metamodel Type",
            "type": "string",
            "description": "The type of the Metamodel class for the Branches in this Repository. If there are no Branches in the Repository, the value is None."
          },
          "dateCreated": {
            "title": "Date Created",
            "type": "string",
            "description": "The date that the repo was created.",
            "format": "date-time"
          },
          "dateModified": {
            "title": "Date Modified",
            "type": "string",
            "description": "The date that the repo was modified.",
            "format": "date-time"
          },
          "branches": {
            "title": "Branches",
            "type": "array",
            "items": { "$ref": "#/components/schemas/BranchRes" },
            "description": "The branches contained in the repo."
          },
          "createdBy": {
            "title": "Created By",
            "type": "object",
            "description": "The Id of the user that created the repo."
          },
          "lastModifiedBy": {
            "title": "last Modified",
            "type": "string",
            "description": "The Id of the user that last modified the repo."
          },
          "project": {
            "title": "Project ID",
            "type": "string",
            "description": "The project ID, which represents the relationship to the project this repository is connected to."
          },
          "repoType": {
            "title": "Repository Type",
            "type": "string",
            "description": "Specifies whether the repository is for a scenario or agent"
          },
          "versions": {
            "title": "Versions",
            "type": "array",
            "items": { "type": "string" },
            "description": "A deprecated alias for the branches field for backwards compatibility."
          }
        }
      },
      "RepoUpdateReq": {
        "title": "RepoUpdateReq",
        "required": ["name"],
        "type": "object",
        "properties": {
          "name": {
            "title": "Name",
            "maxLength": 64,
            "type": "string",
            "description": "The name of the repo."
          },
          "description": {
            "title": "Description",
            "maxLength": 1000,
            "type": "string",
            "description": "The description of the repo."
          },
          "metamodelType": {
            "title": "Metamodel Type",
            "type": "string",
            "description": "The Metamodel type of the repo."
          }
        }
      },
      "Scenario": {
        "title": "Scenario",
        "type": "object",
        "properties": {
          "blocks": {
            "title": "Blocks",
            "type": "object",
            "additionalProperties": { "anyOf": [] },
            "description": "Object that maps all `Block` `id`'s to respective `Block`s in the `Metamodel` instance.",
            "default": {}
          },
          "index": {
            "title": "Index",
            "type": "object",
            "additionalProperties": {
              "type": "array",
              "items": { "type": "string" }
            },
            "description": "Object that maps `Block` class names to subclasses and to `Block` `id`s of the given class."
          },
          "migrated": {
            "title": "Migrated",
            "type": "string",
            "description": "Name of the migration file that was last run on this `Metamodel`."
          },
          "issues": {
            "title": "Issues",
            "allOf": [{ "$ref": "#/components/schemas/Issues" }],
            "description": "Issues encountered during read-time validation."
          },
          "_supers": {
            "title": "Supers",
            "type": "object",
            "description": "Object mapping `Block` class names to a list of names of their direct super classes."
          },
          "_blockNames": {
            "title": "BlockNames",
            "type": "array",
            "items": { "type": "string" },
            "description": "Names of all valid `Block`s for this `Metamodel` class."
          },
          "_relationships": {
            "title": "Relationships",
            "type": "object",
            "description": "Object mapping `Block` class names and `root` to the names of relationship fields. The field names then map to an object of descriptive information about the field."
          },
          "_quantityKinds": {
            "title": "QuantityKinds",
            "description": "Object mapping `Block` class names and `root` to the names of `QuantityKind` fields. The field names then map to an object of descriptive information about the field."
          },
          "clockConfig": {
            "title": "Clockconfig",
            "type": "string",
            "description": "The The clock config id for a scenario."
          },
          "type": {
            "title": "Type",
            "enum": ["Scenario"],
            "type": "string",
            "description": "The \"type\" (class name) of the Metamodel"
          }
        },
        "additionalProperties": false,
        "description": "A Scenario Metamodel"
      },
      "SimulationJob": {
        "title": "SimulationJob",
        "required": ["id", "status", "workspace"],
        "type": "object",
        "properties": {
          "id": {
            "title": "ID",
            "type": "string",
            "description": "The Id of the model."
          },
          "status": {
            "title": "Simulation Status",
            "allOf": [
              {
                "$ref": "#/components/schemas/services__model__spec_models__SimulationJob__Statuses"
              }
            ],
            "description": "This value is used to determine the current state of the simulation, including its status upon exit."
          },
          "bedRef": {
            "title": "Simulation Bed Reference",
            "type": "string",
            "description": "A unique identifier for the Simulation Bed head node."
          },
          "dataArray": {
            "title": "Data Identifier",
            "type": "string",
            "description": "A unique identifier for the Data Service array that stores all of this simulation's data streams."
          },
          "seed": {
            "title": "Simulation Seed",
            "type": "integer",
            "description": "This value is used as part of the seed for the random number generators used throughout the simulation for purposes such as simulated error injection. Simulations are deterministic for a given `seed`."
          },
          "simIndex": {
            "title": "Simulation Index",
            "type": "integer",
            "description": "This value is used for tradespace StudyJobs where each SimJob of the study has a unique incrementing sim_index value assigned to it."
          },
          "overrideID": {
            "title": "Override Identifier",
            "type": "string",
            "description": "A unique identifier for the override document applied to the Simulations initial scenario and agent configuration"
          },
          "snapshotIDs": {
            "title": "Snapshot Identifiers",
            "type": "object",
            "additionalProperties": { "type": "string" },
            "description": "A Dictionary of unique identifiers of snapshot documents used to set the initial scenario and agent configuration for this SimulationJob."
          },
          "scenarioHash": {
            "title": "Scenario Hash",
            "type": "string",
            "description": "A unique hash identifying the scenario and agent configuration for this job."
          },
          "startTime": {
            "title": "Simulation Start Time [MJD]",
            "type": "number"
          },
          "stopTime": {
            "title": "Simulation Stop Time [MJD]",
            "type": "number"
          },
          "realTime": {
            "title": "Real Time Flag",
            "type": "boolean",
            "description": "Coming soon.",
            "default": false
          },
          "progress": {
            "title": "Simulation Progress",
            "allOf": [{ "$ref": "#/components/schemas/Progress" }],
            "description": "This property is missing when simulation status is unknown."
          },
          "auxiliaryServices": {
            "title": "Auxiliary Services",
            "type": "object",
            "description": "A dictionary of auxiliary services used by the simulation."
          },
          "branch": {
            "title": "Scenario Branch ID",
            "type": "string",
            "description": "The ID of the Scenario Branch simulated."
          },
          "createdBy": {
            "title": "Created By",
            "type": "string",
            "description": "The Id of the agent that created the simulation"
          },
          "dataArrayVersion": {
            "title": "Data Version",
            "type": "integer",
            "description": "The version of the Data Service array that stores all of this simulation's data streams."
          },
          "dateCreated": {
            "title": "Date Created",
            "type": "string",
            "description": "The date when the simulation was created."
          },
          "dateModified": {
            "title": "Date Modified",
            "type": "string",
            "description": "The date when the simulation was modified."
          },
          "dateStarted": {
            "title": "Date Started",
            "type": "string",
            "description": "The date when the simulation was Started."
          },
          "exitTime": {
            "title": "Simulation Exit Time [MJD]",
            "type": "number"
          },
          "jobType": {
            "title": "Job Type",
            "type": "string",
            "description": "The SimulationJob type."
          },
          "label": {
            "title": "Label",
            "type": "string",
            "description": "The Simulation label."
          },
          "message": {
            "title": "Message",
            "type": "string",
            "description": "The Simulation Message."
          },
          "predecessor": {
            "title": "Predecessor",
            "type": "string",
            "description": "The predecessor simulation."
          },
          "studyJob": {
            "title": "Study Job",
            "type": "string",
            "description": "The StudyJob Simulation."
          },
          "successors": {
            "title": "Successors",
            "type": "array",
            "items": { "type": "string" },
            "description": "The successors simulations."
          },
          "versions": {
            "title": "Versions",
            "type": "object",
            "additionalProperties": { "type": "string" },
            "description": "The simulation versions."
          },
          "workspace": {
            "title": "Work Space",
            "type": "string",
            "description": "The ID for simulation workspace."
          },
          "studyJobs": {
            "title": "Study Jobs",
            "type": "array",
            "items": { "type": "string" },
            "description": "The of study jobs the the simulation is part of."
          }
        }
      },
      "Spacecraft": {
        "title": "Spacecraft",
        "type": "object",
        "properties": {
          "blocks": {
            "title": "Blocks",
            "type": "object",
            "additionalProperties": { "anyOf": [] },
            "description": "Object that maps all `Block` `id`'s to respective `Block`s in the `Metamodel` instance.",
            "default": {}
          },
          "index": {
            "title": "Index",
            "type": "object",
            "additionalProperties": {
              "type": "array",
              "items": { "type": "string" }
            },
            "description": "Object that maps `Block` class names to subclasses and to `Block` `id`s of the given class."
          },
          "migrated": {
            "title": "Migrated",
            "type": "string",
            "description": "Name of the migration file that was last run on this `Metamodel`."
          },
          "issues": {
            "title": "Issues",
            "allOf": [{ "$ref": "#/components/schemas/Issues" }],
            "description": "Issues encountered during read-time validation."
          },
          "_supers": {
            "title": "Supers",
            "type": "object",
            "description": "Object mapping `Block` class names to a list of names of their direct super classes."
          },
          "_blockNames": {
            "title": "BlockNames",
            "type": "array",
            "items": { "type": "string" },
            "description": "Names of all valid `Block`s for this `Metamodel` class."
          },
          "_relationships": {
            "title": "Relationships",
            "type": "object",
            "description": "Object mapping `Block` class names and `root` to the names of relationship fields. The field names then map to an object of descriptive information about the field."
          },
          "_quantityKinds": {
            "title": "QuantityKinds",
            "description": "Object mapping `Block` class names and `root` to the names of `QuantityKind` fields. The field names then map to an object of descriptive information about the field."
          },
          "_abstractBlockTypes": {
            "title": "Abstract Block Types",
            "type": "object",
            "description": "The abstract block types."
          },
          "activeCommInterfaces": {
            "title": "Active Comm Interfaces",
            "type": "array",
            "items": {},
            "description": "The active comm interfaces."
          },
          "activePointingMode": {
            "title": "Active Pointing Mode",
            "description": "The active pointing mode."
          },
          "activeRoutines": {
            "title": "Active Routines",
            "type": "array",
            "items": {},
            "description": "The active routines."
          },
          "angularAcceleration": {
            "title": "Angular Acceleration",
            "type": "array",
            "items": { "type": "number" },
            "description": "The angular acceleration."
          },
          "angularVelocity": {
            "title": "Angular Velocity",
            "type": "object",
            "description": "The angular velocity."
          },
          "angularVelocitySolution": {
            "title": "Angular Velocity Solution",
            "description": "The angular Velocity solution."
          },
          "angularVelocitySolutionError": {
            "title": "Angular Velocity Solution Error",
            "description": "The angular velocity solution error."
          },
          "attitude": {
            "title": "attitude",
            "type": "object",
            "description": "The attitude."
          },
          "attitudeError": {
            "title": "Attitude Error",
            "description": "The attitudeError."
          },
          "attitudeSolution": {
            "title": "Attitude Solution",
            "description": "The attitude solution."
          },
          "attitudeSolutionError": {
            "title": "Attitude Solution Error",
            "description": "The attitude solution error."
          },
          "attitudeSolutionErrorAngle": {
            "title": "Attitude Solution Error Angle",
            "description": "The attitude solution error angle."
          },
          "beta": { "title": "Beta", "description": "The beta." },
          "cadFileName": {
            "title": "Cad File Name",
            "type": "string",
            "description": "The cad file name."
          },
          "cadKey": {
            "title": "Cad Key",
            "type": "string",
            "description": "The cad key."
          },
          "cadScaleFactor": {
            "title": "Cad Scale Factor",
            "type": "number",
            "description": "The cad scale factor."
          },
          "cadSignedUrl": {
            "title": "Cad Signed Url",
            "type": "string",
            "description": "The cad signed url."
          },
          "cdhTimeStepLimiter": {
            "title": "Cdh Time Step Limiter",
            "description": "The cdh time step limiter."
          },
          "commandedAngularRates": {
            "title": "Commanded Angular Rates",
            "description": "The commanded angular rates."
          },
          "commandedAttitude": {
            "title": "Commanded Attitude",
            "description": "The commanded attitude."
          },
          "definitiveAngularVelocitySolution": {
            "title": "Definitive Angular Velocity Solution",
            "description": "The definitive angular velocity solution."
          },
          "definitiveAngularVelocitySolutionError": {
            "title": "Definitive Angular Velocity Solution Error",
            "description": "The definitive angular velocity solution error."
          },
          "definitiveAttitudeSolution": {
            "title": "Definitive Attitude Solution",
            "description": "The definitive attitude solution."
          },
          "definitiveAttitudeSolutionError": {
            "title": "Definitive Attitude Solution Error",
            "description": "The definitive attitude solution error."
          },
          "definitiveAttitudeSolutionErrorAngle": {
            "title": "Definitive Attitude Solution Error Angle",
            "description": "The definitive attitude solution error angle."
          },
          "definitivePositionSolution": {
            "title": "Definitive Position Solution",
            "description": "The definitive position solution."
          },
          "definitivePositionSolutionError": {
            "title": "Definitive Position Solution Error",
            "description": "The definitive position solution error."
          },
          "definitiveVelocitySolution": {
            "title": "Definitive Velocity Solution",
            "description": "The definitive velocity solution."
          },
          "definitiveVelocitySolutionError": {
            "title": "Definitive Velocity Solution Error",
            "description": "The definitive velocity solution error."
          },
          "dragTorque": {
            "title": "Drag Torque",
            "type": "array",
            "items": { "type": "number" },
            "description": "The drag torque."
          },
          "dynamicCenterOfMass": {
            "title": "Dynamic Center Of Mass",
            "description": "The dynamic center of mass."
          },
          "dynamicInertia": {
            "title": "Dynamic Inertia",
            "description": "The dynamic inertia."
          },
          "dynamicMass": {
            "title": "Dynamic Mass",
            "description": "The dynamic mass."
          },
          "enabledModules": {
            "title": "Enabled Modules",
            "type": "array",
            "items": { "type": "string" },
            "description": "The enabled modules."
          },
          "enuAxes": {
            "title": "Enu Axes",
            "description": "The enu a a axes."
          },
          "estimatedMagneticFieldVector": {
            "title": "Estimated Magnetic Field Vector",
            "description": "The estimated magnetic field vector."
          },
          "gncTimeStepLimiter": {
            "title": "Gnc Time Step Limiter",
            "description": "The gnc time step limiter."
          },
          "gravityGradientTorque": {
            "title": "Gravity Gradient Torque",
            "type": "array",
            "items": { "type": "number" },
            "description": "The gravity gradient torque."
          },
          "inertia": { "title": "Inertia", "description": "The inertia." },
          "lvlhAxes": { "title": "Lvlh Axes", "description": "The lvlh axes." },
          "mass": {
            "title": "Mass",
            "type": "number",
            "description": "The mass."
          },
          "missionOrbit": {
            "title": "Mission Orbit",
            "description": "The mission orbit."
          },
          "orbitalElements": {
            "title": "Orbital Elements",
            "description": "The orbital elements."
          },
          "photometricModel": {
            "title": "Photo Metric Model",
            "type": "object",
            "description": "The photo metric model."
          },
          "pointingErrorAngle": {
            "title": "Pointing Error Angle",
            "description": "The pointing error angle."
          },
          "pointingModesMainRoutine": {
            "title": "Pointing Modes Main Routine",
            "description": "The pointing modes main routine."
          },
          "position": { "title": "Position", "description": "The position." },
          "positionSolution": {
            "title": "Position Solution",
            "description": "The position solution."
          },
          "positionSolutionError": {
            "title": "Position Solution Error",
            "description": "The position solution error."
          },
          "powerProcessor": {
            "title": "Power Processor",
            "type": "string",
            "description": "The power processor."
          },
          "powerTimeStepLimiter": {
            "title": "Power Time Step Limiter",
            "description": "The power time step limiter."
          },
          "predictiveAngularVelocitySolution": {
            "title": "Predictive Angular Velocity Solution",
            "description": "The predictive angular velocity solution."
          },
          "predictiveAngularVelocitySolutionError": {
            "title": "Predictive Angular Velocity Solution Error",
            "description": "The predictive angular velocity solution error."
          },
          "predictiveAttitudeSolution": {
            "title": "Predictive Attitude Solution",
            "description": "The predictive attitude solution."
          },
          "predictiveAttitudeSolutionError": {
            "title": "Predictive Attitude Solution Error",
            "description": "The predictive attitude solution error."
          },
          "predictiveAttitudeSolutionErrorAngle": {
            "title": "Predictive Attitude Solution Error Angle",
            "description": "The predictive attitude solution error angle."
          },
          "predictivePositionSolution": {
            "title": "Predictive Position Solution",
            "description": "The predictive position solution."
          },
          "predictivePositionSolutionError": {
            "title": "Predictive Position Solution Error",
            "description": "The predictive position solution error."
          },
          "predictiveVelocitySolution": {
            "title": "Predictive Velocity Solution",
            "description": "The predictive velocity solution."
          },
          "predictiveVelocitySolutionError": {
            "title": "Predictive Velocity Solution Error",
            "description": "The predictive velocity solution error."
          },
          "selfId": { "title": "SelfId", "description": "The selfId." },
          "shadow": { "title": "Shadow", "description": "The shadow." },
          "srpTorque": {
            "title": "SrpTorque",
            "type": "array",
            "items": { "type": "number" },
            "description": "The srpTorque."
          },
          "thermalTimeStepLimiter": {
            "title": "Thermal Time Step Limiter",
            "description": "The thermal time step limiter."
          },
          "timeStepConstraints": {
            "title": "Time Step Constraints",
            "description": "The time step constraints."
          },
          "torque": {
            "title": "Torque",
            "type": "array",
            "items": { "type": "number" },
            "description": "The torque."
          },
          "velocity": { "title": "Velocity", "description": "The velocity." },
          "velocitySolution": {
            "title": "VelocitySolution",
            "description": "The velocity solution."
          },
          "velocitySolutionError": {
            "title": "VelocitySolutionError",
            "description": "The velocity solution error."
          },
          "type": {
            "title": "Type",
            "enum": ["Spacecraft"],
            "type": "string",
            "description": "The \"type\" (class name) of the Metamodel"
          }
        },
        "additionalProperties": false,
        "description": "A Spacecraft Metamodel"
      },
      "StartSimulationBody": {
        "title": "StartSimulationBody",
        "type": "object",
        "properties": {
          "seed": {
            "title": "Simulation Seed",
            "type": "integer",
            "description": "This value is used as part of the seed for the random number generators used throughout the simulation for purposes such as simulated error injection. Simulations are deterministic for a given `seed`."
          }
        }
      },
      "StartStudyBody": {
        "title": "StartStudyBody",
        "type": "object",
        "properties": {
          "iterations": {
            "title": "Study Iterations",
            "type": "integer",
            "description": "The number of simulations to run as part of this Study."
          }
        }
      },
      "StudyJob": {
        "title": "StudyJob",
        "required": [
          "id",
          "status",
          "scenarioHash",
          "branch",
          "jobType",
          "label",
          "message",
          "workspace"
        ],
        "type": "object",
        "properties": {
          "id": {
            "title": "ID",
            "type": "string",
            "description": "The Id of the study."
          },
          "status": {
            "title": "Simulation Status",
            "allOf": [
              {
                "$ref": "#/components/schemas/services__model__spec_models__StudyJob__Statuses"
              }
            ],
            "description": "This value is used to determine the current state of the simulation, including its status upon exit."
          },
          "scenarioHash": {
            "title": "Scenario Hash",
            "type": "string",
            "description": "A unique hash identifying the scenario and agent configuration for this job."
          },
          "overrideID": {
            "title": "Override Identifier",
            "type": "string",
            "description": "A unique identifier for the override document applied to the Simulations initial scenario and agent configuration"
          },
          "branch": {
            "title": "Branch",
            "type": "string",
            "description": "Study Scenario branch"
          },
          "dateCreated": {
            "title": "Date Created",
            "type": "string",
            "description": "The date when the study was created."
          },
          "dateModified": {
            "title": "Date Modified",
            "type": "string",
            "description": "The date when the study was modified."
          },
          "jobType": {
            "title": "Job Type",
            "type": "string",
            "description": "The Study job type."
          },
          "simulationJobs": {
            "title": "Simulation Jobs",
            "type": "array",
            "items": { "type": "string" },
            "description": "The list of simulation jobs in the study."
          },
          "label": {
            "title": "Label",
            "type": "string",
            "description": "The Study label."
          },
          "message": {
            "title": "Message",
            "type": "string",
            "description": "The Study Message."
          },
          "predecessor": {
            "title": "Predecessor",
            "type": "string",
            "description": "The predecessor simulation."
          },
          "successors": {
            "title": "Successors",
            "type": "array",
            "items": { "type": "string" },
            "description": "The successors simulations."
          },
          "versions": {
            "title": "Versions",
            "type": "object",
            "additionalProperties": { "type": "string" },
            "description": "The simulation versions."
          },
          "workspace": {
            "title": "Work Space",
            "type": "string",
            "description": "The ID for simulation workspace."
          }
        }
      },
      "TerrestrialVehicle": {
        "title": "TerrestrialVehicle",
        "type": "object",
        "properties": {
          "blocks": {
            "title": "Blocks",
            "type": "object",
            "additionalProperties": { "anyOf": [] },
            "description": "Object that maps all `Block` `id`'s to respective `Block`s in the `Metamodel` instance.",
            "default": {}
          },
          "index": {
            "title": "Index",
            "type": "object",
            "additionalProperties": {
              "type": "array",
              "items": { "type": "string" }
            },
            "description": "Object that maps `Block` class names to subclasses and to `Block` `id`s of the given class."
          },
          "migrated": {
            "title": "Migrated",
            "type": "string",
            "description": "Name of the migration file that was last run on this `Metamodel`."
          },
          "issues": {
            "title": "Issues",
            "allOf": [{ "$ref": "#/components/schemas/Issues" }],
            "description": "Issues encountered during read-time validation."
          },
          "_supers": {
            "title": "Supers",
            "type": "object",
            "description": "Object mapping `Block` class names to a list of names of their direct super classes."
          },
          "_blockNames": {
            "title": "BlockNames",
            "type": "array",
            "items": { "type": "string" },
            "description": "Names of all valid `Block`s for this `Metamodel` class."
          },
          "_relationships": {
            "title": "Relationships",
            "type": "object",
            "description": "Object mapping `Block` class names and `root` to the names of relationship fields. The field names then map to an object of descriptive information about the field."
          },
          "_quantityKinds": {
            "title": "QuantityKinds",
            "description": "Object mapping `Block` class names and `root` to the names of `QuantityKind` fields. The field names then map to an object of descriptive information about the field."
          },
          "_abstractBlockTypes": {
            "title": "AbstractBlockTypes",
            "type": "object",
            "description": "The abstract block types."
          },
          "activeRoutines": {
            "title": "ActiveRoutines",
            "type": "array",
            "items": {},
            "description": "The active routines."
          },
          "angularAcceleration": {
            "title": "Angular Acceleration",
            "type": "array",
            "items": { "type": "number" },
            "description": "The angular acceleration."
          },
          "angularVelocity": {
            "title": "Angular Velocity",
            "type": "object",
            "description": "The angular velocity."
          },
          "attitude": {
            "title": "Attitude",
            "type": "object",
            "description": "The attitude."
          },
          "beta": { "title": "Beta", "description": "The beta." },
          "cadFileName": {
            "title": "Cad File Name",
            "type": "string",
            "description": "The cadFileName."
          },
          "cadKey": {
            "title": "CadKey",
            "type": "string",
            "description": "The cadKey."
          },
          "cadScaleFactor": {
            "title": "CadSca leFactor",
            "type": "number",
            "description": "The cadScaleFactor."
          },
          "cadSignedUrl": {
            "title": "Cad Signed Url",
            "type": "string",
            "description": "The cad signed url."
          },
          "cdhTimeStepLimiter": {
            "title": "Cdh Time Step Limiter",
            "description": "The cdh time step limiter."
          },
          "currentWaypointPath": {
            "title": "Current Waypoint Path",
            "description": "The current waypoint path."
          },
          "enabledModules": {
            "title": "Enabled Modules",
            "type": "array",
            "items": { "type": "string" },
            "description": "The enabled modules."
          },
          "gncTimeStepLimiter": {
            "title": "Gnc Time Step Limiter",
            "description": "The gnc time step limiter."
          },
          "position": { "title": "Position", "description": "The position." },
          "powerProcessor": {
            "title": "PowerProcessor",
            "type": "string",
            "description": "The power processor."
          },
          "rainData": { "title": "Rain Data", "description": "The rain data." },
          "ramVector": {
            "title": "Ram Vector",
            "description": "The ram vector."
          },
          "selfId": { "title": "Self Id", "description": "The self id." },
          "shadow": { "title": "Shadow", "description": "The shadow." },
          "solarAzimuth": {
            "title": "Solar Azimuth",
            "type": "number",
            "description": "The solar azimuth."
          },
          "solarElevation": {
            "title": "Solar Elevation",
            "type": "number",
            "description": "The solar elevation."
          },
          "timeStepConstraints": {
            "title": "Time Step Constraints",
            "description": "The time step constraints."
          },
          "upVector": { "title": "Up Vector", "description": "The up vector." },
          "velocity": { "title": "Velocity", "description": "The velocity." },
          "type": {
            "title": "Type",
            "enum": ["TerrestrialVehicle"],
            "type": "string",
            "description": "The \"type\" (class name) of the Metamodel"
          }
        },
        "additionalProperties": false,
        "description": "A TerrestrialVehicle Metamodel"
      },
      "ValidationError": {
        "title": "ValidationError",
        "required": ["loc", "msg", "type"],
        "type": "object",
        "properties": {
          "loc": {
            "title": "Location",
            "type": "array",
            "items": { "anyOf": [{ "type": "string" }, { "type": "integer" }] }
          },
          "msg": { "title": "Message", "type": "string" },
          "type": { "title": "Error Type", "type": "string" }
        }
      },
      "services__model__spec_models__SimulationJob__Statuses": {
        "title": "Statuses",
        "enum": [
          "PENDING",
          "RUNNING",
          "PAUSED",
          "TERMINATED",
          "FAILED",
          "SUCCEEDED",
          "ERROR",
          "PROVISIONING",
          "CONFIGURING",
          "BUILDING",
          "DEPLOYING",
          "CONNECTION_ERROR",
          "QUEUED"
        ],
        "description": "An enumeration."
      },
      "services__model__spec_models__StudyJob__Statuses": {
        "title": "Statuses",
        "enum": [
          "PENDING",
          "RUNNING",
          "PAUSED",
          "TERMINATED",
          "FAILED",
          "SUCCEEDED",
          "ERROR",
          "PROVISIONING",
          "CONFIGURING",
          "BUILDING",
          "DEPLOYING",
          "CONNECTION_ERROR",
          "QUEUED"
        ],
        "description": "An enumeration."
      }
    },
    "securitySchemes": {
      "api_key_header_api_key": {
        "type": "apiKey",
        "description": "Sedaro API Key",
        "in": "header",
        "name": "X_API_KEY"
      },
      "api_key_header_auth_handle": {
        "type": "apiKey",
        "description": "Sedaro Auth Handle",
        "in": "header",
        "name": "X_AUTH_HANDLE"
      }
    }
  },
  "servers": [
    {
      "url": "https://api.sedaro.com",
      "description": "Sedaro Multi-Tenant Platform API (Note: uses live data)"
    }
  ],
  "tags": [
    { "name": "Branches", "description": "" },
    {
      "name": "Data",
      "description": "\n### Queries\n\nAs of December 2023, Sedaro's data service has been overhauled. Different parameters are now required for requests. If your simulation\nwas run before this time, you will continue to use the old interface (see below).\n\nThe data service now returns data in pages, instead of all at once. Data for a sim, within the given query parameters, is progressively\nadded to a page until it is full. At that point, the page is sent to the client and the server begins assembling the next page. This continues\nuntil all data for the query has been fetched and paginated.\n\nDownsampling has also been reworked. Instead of specifying an arbitrary number of bins, or an arbitrary bin width, data is now available\nfor egress at fixed resolutions, following the powers of 2. Therefore, data can be downloaded at full resolution, at 1/2 resolution, at\n1/4 resolution, and so on. This is achieved by including, respectively, every frame, every second frame, every fourth frame, and so forth.\nThis way, unlike in the previous downsampling scheme, more data points will be presented where the data is dense, and fewer data points\nwill be presented where the data is sparse.\n\nThe desired downsample level, or 'rank', are specified by the `sampleRate` parameter. The value of `sampleRate` corresponds to the\ndenominator of the corresponding downsample level. For instance, to request data at 1/8 resolution, set a `sampleRate` resolution of 8.\nTo request data at full resolution, set `sampleRate` to 1.\n\nHere is an example, looking at the first 40 frames of a data series. '#' indicates a frame included in the series of a given rank.\n'_' indicates a frame *not* included in that rank.\n\n```text\n1   # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #\n2   # _ # _ # _ # _ # _ # _ # _ # _ # _ # _ # _ # _ # _ # _ # _ # _ # _ # _ # _ # _\n4   # _ _ _ # _ _ _ # _ _ _ # _ _ _ # _ _ _ # _ _ _ # _ _ _ # _ _ _ # _ _ _ # _ _ _\n8   # _ _ _ _ _ _ _ # _ _ _ _ _ _ _ # _ _ _ _ _ _ _ # _ _ _ _ _ _ _ # _ _ _ _ _ _ _\n16  # _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ # _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ # _ _ _ _ _ _ _\n32  # _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ # _ _ _ _ _ _ _\n```\n\nA separate query is made for each page. Each returned page contains a 'continuation token' in its body. Inside the response content,\nthis continuation token can be found at response['meta']['continuationToken']. Pass this value as the `continuationToken` for the\nnext page you request. Continue doing so until an empty token is returned. At that point, there is no more data to return, and\nfurther page requests should not be made.\n\nIn all requests, either a sampleRate or a continuation token must be provided. It is not necessary to specify a sampleRate when a request\nincludes a continuation token.\n\nNew interface:\n- `id`: The ID of the data set to query.  This ID is defined on a [Simulation Job](#tag/Jobs).\n- `start`: The start time of the window in MJD. If omitted, defaults to the minimum timestamp in the dataset.\n- `stop`: The stop time of the window in MJD. If omitted, defaults to the maximum timestamp in the dataset.\n- `streams`: (optional) The specific agents and engines for which to fetch data. If omitted, all streams are fetched.\n    This argument takes the form of a list of requests separated by commas.\n    A request can have either one or two elements. The first element is always the ID of the Agent (str).\n    The second element (optional) is the name of an engine (str). This must be one of the following: 'GNC', 'CDH', 'Power', 'Thermal'.\n    If the second element is not provided, all data from all engines of the given Agent are fetched. If a request has two elements, they are\n    separated by a period. Here is an example:\n\n    ...&streams=NT06aqHUT5djI1_JPAsck.CDH,NT06aqHUT5djI1_JPAsck.Power,NT0Ln1gS8elWEK4Y-l7m-\n\n    This will fetch the Power and CDH data for Agent(id='NT06aqHUT5djI1_JPAsck'), and all data for\n    Agent(id='NT0Ln1gS8elWEK4Y-l7m-').\n- `streamsToken`: (optional) A token corresponding to a list of streams, as retrieved from the `metadata` endpoint\n    (see below). If both `streamsToken` and `streams` are provided, the value of `streams` takes precedence.\n- `shape` (optional): Specifies whether the data should be nested or flat. Options: `FLAT` (default) and `NESTED`. Examples:\n    Flat: {'a.b': [1, 2, 3], 'a.c': [4, 5, 6]}\n    Nested: {'a': {'b': [1, 2, 3], 'c': [4, 5, 6]}}\n- `axisOrder`: (optional) The shape of each series in the response. Options: `TIME_MINOR` (default) and `TIME_MAJOR`. NOTE: unlike the old\n    Data Service in which the default was `TIME_MAJOR`, the default in the new Data Service is `TIME_MINOR`. Examples:\n    Data at time 1: [1, 2]\n    Data at time 2: [3, 4]\n    Data at time 3: [5, 6]\n    TIME_MINOR: [[1, 3, 5], [2, 4, 6]]\n    TIME_MAJOR: [[1, 2], [3, 4], [5, 6]]\n- `binWidth`: (optional, temporarily disabled) The bin width to use to down-sample the data.  If omitted, data will be full resolution.\n- `sampleRate`: (optional) The downsampling rank to use. `1` for full resolution, `2` for half resolution, `4` for 1/4 resolution,\n    and so on. Must be an integer power of 2. Required if no `continuationToken` is provided.\n- 'continuationToken' (optional) Required if no `sampleRate` is provided. Retrieved from the previously fetched page, as described above.\n- 'encoding' (optional) The encoding in which to receive data. Currently accepted values are `json` and `msgpack`. Default: json.\n\n    Note: Timestamps of individual data points are left-inclusive and right-exclusive. For example, if `start` is 2 and `stop` is 5,\n    and there are timestamps at 1, 3, and 5, all three data points will be included, not just the data points at 1 and 3. This is\n    because the data point at timestamp 1 is valid for the time range [1, 3) and part of this time range is included in the query.\n\n\nFor simulation runs performed before the release and deployment of Data Service v3 in December 2023, continue to use the following interface:\n\n- `id`: The ID of the data set to query.  This ID is defined on a [Simulation Job](#tag/Jobs).\n- `start`: The start time of the window in MJD. If omitted, defaults to the minimum timestamp in the dataset.\n- `stop`: The stop time of the window in MJD. If omitted, defaults to the maximum timestamp in the dataset.\n- `binWidth`: (optional) The bin width to use to down-sample the data.  If omitted, data will be full resolution.\n- `axisOrder`: (optional) The shape of each series in the response. Options: `TIME_MAJOR` (default) and `TIME_MINOR`.\n- `streams`: (optional) The specific agents and engines for which to fetch data. If omitted, all streams are fetched.\n    This argument, if provided, follows the same syntax specified above for the `streams` parameter in the new interface.\n- `streamsToken`: (optional) A token corresponding to a list of streams, as retrieved from the `metadata` endpoint\n    (see below). If both `streamsToken` and `streams` are provided, the value of `streams` takes precedence.\n\n    Example request: `GET: /data/<id>?start=<start>&stop=<stop>&binWidth=<binWidth>`\n\n#### Response\n\nData is returned from a query in the following format:\n\n```json\n{\n    \"series\": {\n        <streamId>: [\n            [<timestamp1::MJD>, <timestamp2::MJD>, ...],\n            {\n                <agentId>: {\n                    <blockId>: {\n                        <stateVariableA>: [<valueA1>, <valueA2>, ...],\n                        <stateVariableB>: [<valueB1>, <valueB2>, ...],\n                        ...\n                    },\n                    <stateVariableC>: [<valueC1>, <valueC2>, ...]\n                },\n                ...\n            }\n        ],\n        ...\n    }\n}\n```\n\nNote that a \"Stream\" is a set of state variables that share the same timestamps.  Specifically, the values in a Stream\ncorrespond to a modsim Engine of a particular Agent.  The `series` object contains a key for each stream in the data set.\nThe value of each stream key is a 2-element array.  The first element is an array of timestamps - the X-axis for all variables\nin the stream.  The second element is an object containing the state variables that compose the stream.  The state variables\nare grouped under an Agent ID and then a Block ID (if applicable).  The value of each entry is an array of values that aligns\nwith the timestamp vector.\n\n#### Axis Order (`axisOrder`)\n\nAxis order defines the shape of each multi-dimensional series in the Data Service query response.  In the following example,\n`n` is the time dimension, `position` is a notional State Variable of shape `(3,)`, and `matrix` is a notional State Variable\nof shape `(3, 4)`.\n\n**`TIME_MAJOR`**\n- `position.shape == (n, 3)`\n- `matrix.shape == (n, 3, 4)`\n\n**`TIME_MINOR`**\n- `position.shape == (3, n)`\n- `matrix.shape == (3, 4, n)`\n\n### Batch Fetching\n\n\"Batch fetching\" is a Data Service mode that enables parallel downloading of multiple pages of data from the same query.\nIt consists of two steps. The first step is the \"prefetch\". The prefetch endpoint is located at the URL `/data/<id>/batch/`,\nwhere `<id>` is the ID of the Simulation Job to query. This endpoint accepts the `start`, `stop`, `streams`, and `sampleRate`\nparameters as described above. The `sampleRate` parameter is mandatory.\n\nWhen called, this endpoint will return a JSON object containing a list of UUIDs. Each of these UUIDs will be sent to the\ndata query endpoint as the `continuationToken` parameter. The data query endpoint will then return the corresponding page of data.\nThese pages can be fetched in parallel, and in any order. Note that these UUIDs are only valid for a limited time, and will expire\nif not used within a certain period. By default, this period is 3 hours, but it may be configured differently on a given server.\n\nIn addition to the parameters listed above, the prefetch endpoint also accepts one additional optional parameter:\n\n- `num_pages`: The number of pages for which to generate UUIDs. If omitted, defaults to 25.\n\n`num_pages` values above 100 will be capped at 100.\n\nIf, after generating UUIDs for the specified pages, the data set corresponding to the provided query parameters has not been fully\nprocessed, this endpoint will return a `continuationToken` that can be used to fetch the next batch of UUIDs. This token should be\nprovided as the `continuationToken` parameter in the next call to the prefetch endpoint. If the data set has been fully processed,\nthe `continuationToken` will be null.\n\nPages, once fetched, must be assembled in the order in which their corresponding UUIDs were provided by this endpoint.\n\n#### Response\n\nData is returned from a query in the following format:\n```jsonc\n{\n    \"tokens\": [<UUID1>, <UUID2>, ...],\n    \"continuationToken\": null | <token (str)>\n}\n```\n\n### Ephemerides\n\nThe Data Service also includes an endpoint for bulk fetching of ephemerides. The following parameters are exposed:\n`start` (required): the start of the time range within which to fetch ephemerides, in MJD.\n`stop` (required): the end of the time range within which to fetch ephemerides, in MJD.\n`resolution`: the spacing at which to fetch ephemerides. For instance, if `resolution` is 0.1, then data will be fetched\nat start time, start + 0.1, start + 0.2, etc, up until the stop time is reached.\n`bodies`: the celestial bodies for which to fetch ephemerides. Supported bodies are SUN, MERCURY, VENUS, EARTH, MOON,\nMARS, JUPITER, SATURN, URANUS, NEPTUNE, and PLUTO. If this parameter is not provided, all supported bodies are included.\n`axisOrder`: TIME_MAJOR or TIME_MINOR, as above. Defaults to TIME_MINOR if not specified.\n\nLike the data API, the ephemerides API uses paging to handle large ephemerides requests. If your request is for more than\n100,000 data points, it will be broken up into pages of 100,000 data points at a time. In this case, a continuation token\nwill be provided along with the page data. To get the next page, instead of using the parameters above, simply pass back\nthe value of response['continuationToken'] as the argument to the `continuationToken` parameter, and repeat until the value\nthe value of `response.meta.continuationToken` as the argument to the `continuationToken` parameter, and repeat until the value\nof `response.meta.continuationToken` is a null object.\n\nExample request: `GET: /data/<id>/ephemerides?start=<start>&stop=<stop>&resolution=<resolution>&bodies=<bodies>`\n\n#### Response\n\nData is returned from a query in the following format:\n```json\n{\n    \"meta\": {\"continuationToken\" : null | <token (str)>},\n    \"series\": [\n        [<timestamp1::MJD>, <timestamp2::MJD>, ...],\n        {\n            <celestialBodyID>: [<values>],\n            <celestialBodyID>: [<values>],\n            ...\n        }\n    ]\n}\n```\n\n### Metadata\n\nThe Data Service also features an endpoint for fetching certain metadata about a simulation run without fetching\nthe data itself. It has one optional parameter, and the endpoint's response will take one of two forms depending\non whether a value is provided for that parameter.\n\nMode 1: no parameters. This mode will return the start and stop times of the simulation, in MJD, and a list of all\nstreams in the simulation, in the format used by the `streams` parameter of the data fetching endpoint (see above).\n\nExample request: `GET: /data/<id>/metadata`\n\nIn this case, the response will look like this:\n```jsonc\n{\n    \"start\": <start::MJD>,\n    \"stop\": <stop::MJD>,\n    \"streams\": [<stream1>, <stream2>, ...]\n}\n```\n\nMode 2: a value is provided for the optional `numTokens` parameter. This mode will return a list of UUIDs (tokens),\neach one corresponding to a list of streams in the simulation. Each such list will contain 1/n of the streams in the\nsimulation, where n is the value of the `numTokens` parameter. If the number of streams in the simulation `numStreams`\nis smaller than `numTokens`, then the response will contain `numStreams` tokens.\n\nExample request: `GET: /data/<id>/metadata?numTokens=4`\n\nIn this case, the response will look like this:\n```jsonc\n{\n    \"start\": <start::MJD>,\n    \"stop\": <stop::MJD>,\n    \"streamsTokens\": [<token1>, <token2>, ...]\n}\n```\n\n"
    },
    {
      "name": "Metamodels",
      "description": "\n### Introduction to Modeling in Sedaro\n\nSedaro uses **SedaroML** (Sedaro Modeling Language) to define models and systems of models. SedaroML defines system\nproperties and structure as normalized, interrelated, and hierarchical blocks of attributes. SedaroML is JSON-based and\nis designed to be easily human and machine readable/writeable. This includes model interpretation, traversal, etc. Each\nSedaroML model class defining the structure and properties of a system is called a `Metamodel`.\n\n`Metamodel` classes are instantiated to create instances of the system. `Metamodel` instances consist of a set of\n`Block`s and `attributes` (described below) and can be either **Agent Templates** or **Scenarios**.\n\n- Agent Templates: define the model for a system.\n- Scenarios: define the instantiation of a system and the configuration of the simulation.\n\nWhen a Scenario configures a simulation, it instantiates Agent Templates to create **Agents**.  The Agents are then\nconnected to each other to form a system of systems.  This system is then simulated according to the Scenario's configuration.\n\nTo help with organization and other functionality, each instantiated `Metamodel` is associated with a `Branch` that is apart\nof a `Repository`. This allows for versioning, branching, merging, and tracking of changes to the `Metamodel` and the\nsystem it defines. The `Metamodel` is stored in the `data` key of the `Branch` JSON object.\n\n#### Other key concepts\n\nThere are some specific concepts in SedaroML that are important to understand:\n  - **Attributes:** Individual properties of a `Block` (e.g., `mass`, `voltage`, etc.) captured as a key-value pair.\n\n  - **Root:** The `root` refers to the highest level key/value pairs of the JSON-object of SedaroML. The keys are\n    attributes, just like on `Block`s, but `root` is not a `Block` itself. All `Metamodel`s contain `blocks` and `index`\n    attributes in `root` which store and help with querying for all `Block`s in the `Metamodel`.\n\n  - **Blocks:** A `Block` is a set of attributes, including a `type` which defines the type of the `Block` (e.g.,\n    `ReactionWheel`, `Battery`, etc.). All `Block`s are located under the `blocks` attribute of the model.\n\n  - **Hierarchy:** The `Block`s in a SedaroML model have hierarchy such that a `Block` `type` can extend one or more\n    `Block` `type`s (e.g., a `ReactionWheel` is a specialized `Actuator` and an `Actuator` is a specialized\n    `Component`). The hierarchy of a model can be interpreted using the `index` and `_supers` meta attributes of a\n    `Metamodel`.  `index` provides a lookup to traverse from a `Block` `type` to its sub-`Block` `type`s, ultimately\n    down to the individual `Block` instances in the model. `_supers` provides a lookup to traverse from a `Block` `type`\n    to its super-`Block` `type`s.\n\n  - **Relationships:** The model `root` and its `Block`s can be related to one another using relationship attributes.\n    The `_relationships` meta attribute provides a lookup from `Block` `type` to that `type`'s relationships attributes.\n\n  - **Quantity Kinds:** In SedaroML, an attribute that has a value and a unit is called a \"Quantity\". Quantities may be\n    composed of other Quantities, called Compound Quantities. A category of Quantities that share the same unit system\n    is called a \"Quantity Kind\".  If a model attribute is an explicit Quantity, it will be included in the\n    `_quantityKinds` meta attribute lookup. Attributes that are Explicit Quantity Kinds may be defined in any of the\n    supported units for the Quantity Kind. For example, all angle attributes in SedaroML may be defined in either\n    degrees or radians. If the unit isn't provided, the default unit for the given Quantity Kind is assumed.\n\nSedaroML is used to define both Agent Templates and Scenario models, with Scenario models referencing Agent Template    Branches (and therefore their models) via the `templateRef` attribute of an `Agent` Block.\n\n<details>\n<summary>Expand for an example of a mock `Metamodel` instance in a `Branch` `data` key, demonstrating some of the meta attributes:M</summary>\n\n```json\n{\n    \"type\": \"Spacecraft\",\n    \"blocks\": {\n        \"N05o9ixRguGxORKXZ_123\": {\n        \"id\": \"N05o9ixRguGxORKXZ_123\",\n            \"type\": \"Battery\",\n            \"packs\": [\"N05oGhcT-9k9vSTAGn456\"]\n        },\n        \"N05oGhcT-9k9vSTAGn456\": {\n            \"id\": \"N05oGhcT-9k9vSTAGn456\",\n            \"type\": \"BatteryPack\",\n            \"battery\": \"N05o9ixRguGxORKXZ_123\"\n        }\n        \"N05o79yULy9NUw1zTk789\": {\n        \"id\": \"N05o79yULy9NUw1zTk789\",\n            \"type\": \"ReactionWheel\",\n            \"inertia\": 0.1\n        },\n    },\n    \"index\": {\n        \"Actuator\": [\"ReactionWheel\"],\n        \"Component\": [\"Battery\", \"BatteryPack\", \"Actuator\"],\n        \"Battery\": [\"N05o9ixRguGxORKXZ_123\"],\n        \"BatteryPack\": [\"N05oGhcT-9k9vSTAGn456\"],\n        \"ReactionWheel\": [\"N05o79yULy9NUw1zTk789\"]\n    },\n    \"_blockNames\": ['Battery', 'BatteryPack', 'ReactionWheel'],\n    \"_quantityKinds\": {\n        \"Battery\": {},\n        \"BatteryPack\": {\n            \"coldTempRating\": \"Temperature\",\n            \"hotTempRating\": \"Temperature\",\n            \"temperature\": \"Temperature\"\n        },\n        \"ReactionWheel\": {\n            \"coldTempRating\": \"Temperature\",\n            \"hotTempRating\": \"Temperature\",\n            \"temperature\": \"Temperature\"\n        },\n    },\n    \"_relationships\": {\n        \"Battery\": {\n            \"packs\": {\n                \"inverse\": \"battery\",\n                \"onDelete\": \"set-none\",\n                \"optional\": false,\n                \"target\": \"BatteryPack\",\n                \"type\": \"ManySide\"\n            },\n        },\n        \"BatteryPack\": {\n            \"battery\": {\n                \"inverse\": \"packs\",\n                \"onDelete\": \"set-none\",\n                \"optional\": false,\n                \"target\": \"Battery\",\n                \"type\": \"OneSide\"\n            },\n        },\n    },\n    \"_supers\": {\n        \"Actuator\": [\"Component\"],\n        \"Battery\": [\"Component\"],\n        \"BatteryPack\": [\"Component\"],\n        \"ReactionWheel\": [\"Actuator\"],\n        \"Component\": []\n    }\n}\n```\n\n</details>\n"
    },
    {
      "name": "Externals",
      "description": "\n### Introduction\n\"Cosimulation\" refers to multiple simulators working in conjunction to simulate something. Cosimulation in Sedaro is\nachieved via the definition of `ExternalState` `Block`s within a Scenario model.  `ExternalState` `Block`s are related to\none or more `Agent` `Block`s in the Scenario model and they define the external cosimulation interfaces.  Interfaces can\nbe uni- or bi-directional and support two different modes: `Per-Round` and `Spontaneous`.\n\n### Cosimulation Modes\nIn `Per-Round` cosimulation, the external simulator is expected to produce and/or consume state at each \"round\" or\nsimulation Engine time-step. In `Spontaneous` cosimulation, the external simulator may produce and/or consume state at\nany time. This method of cosimulation is recommended for real-time simulations (`ClockConfig.realTime == true`) and\nis important for use-cases such as commanding a system or part of a system to a new state (i.e., human/software-in-the-loop).\n\n`Spontaneous` state is timestamped and interpreted such that it impacts the simulation during the round at or immediately\nfollowing the `timestamp`. Spontaneous state production is also unique in that it is not required to ever provide a\nvalue and can remain optionally unused during a simulation. In this case, the simulation will continue to consume the\ninitial value for the state until a new value is provided.\n\nEach cosimulation interface is independent meaning some may be `Per Round` while others are `Spontaneous`.  This also\nmeans that individual cosimulators can consume/produce state simulataneously over different interfaces.\n\n### Blocking vs Non-Blocking\n#### Per-Round\nIf simulation state depends on `produced` external state, the simulation will block (or wait) until this state is provided\nvia the following `PATCH` endpoint.  Once provided, the simulation will continue until it is blocked again. Anything that\nis not dependent on the external state will continue to run during the blocking period.\n\n#### Spontaneous\nSpontaneous external state will never block the simulation but will take effect upon arrival.\n\n#### Consume\nCalling `consume` with a `time` value that the simulation hasn't reached yet will block until the simulation catches up.\nThis is currently subject to a **10 minute timeout**. If the request fails after 10 minutes, it is recommended that it\nbe reattempted.\n\nSimilarly, calling `consume` with a `time` that too far lags the current simulation might result in an error as the\nvalue has been garbage collected from the simulation caches and is no longer available for retrieval. If this is the\ncase, please fetch the data from the Data Service (via the Results API) instead.\n\n### Numpy Array Serialization/Deserialization\nBecause all requests and responses of this API must be JSON serializable, numpy arrays are represented in the following\nway in both API requests and responses (as a representation of the value `np.array([x, y, z])`):\n\n```json\n{\n    \"ndarray\": [x, y, z]\n}\n```\n\n### Configuring Cosimulation\nCosimulation interfaces are configured via the definition of `ExternalState` Blocks on the [Scenario model](#tag/Metamodels) before the simulation\nis started. The currently supported Blocks are `PerRoundExternalState` and `SpontaneousExternalState`.\n\nSee the [Metamodels](#tag/Metamodels) section for details on defining Blocks and their individual attributes.\n\nExample Blocks:\n\n```json\n// Per Round External State Block\n{\n    \"id\": \"NZ2SGPWRnmdJhwUT4GD5k\",\n    \"type\": \"PerRoundExternalState\",\n    \"produced\": [{\"root\": \"velocity\"}], // Implicit QuantityKind\n    \"consumed\": [{\"prev.root.position.as\": \"Position.eci\"}], // Explicit QuantityKind\n    \"engineIndex\": 0, // 0: GNC, 1: C&DH, 2: Power, 3: Thermal\n    \"agents\": [\"NSghFfVT8ieam0ydeZGX-\"]\n}\n\n// Spontaneous External State Block\n{\n    \"id\": \"NZ2SHUkS95z1GtmMZ0CTk\",\n    \"type\": \"SpontaneousExternalState\",\n    \"produced\": [{\"root\": \"activeOpMode\"}],\n    \"consumed\": [{\"prev.root.position.as\": \"Position.eci\"}],\n    \"engineIndex\": 0, // 0: GNC, 1: C&DH, 2: Power, 3: Thermal\n    \"agents\": [\"NSghFfVT8ieam0ydeZGX-\"]\n}\n```\n\nOnce the simulation is running, the following endpoints are used to interact with any cosimulation interfaces.\n"
    }
  ],
  "x-tagGroups": [
    { "name": "Metamodels", "tags": ["Metamodels"] },
    { "name": "Simulation", "tags": ["Jobs"] },
    { "name": "Data", "tags": ["Data"] },
    { "name": "Repositories", "tags": ["Repositories", "Branches"] },
    { "name": "Cosimulation", "tags": ["Externals"] }
  ]
}
